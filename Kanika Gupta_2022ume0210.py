# -*- coding: utf-8 -*-
"""CV Ass_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XtyH2biM_dV1JW4iUSMutDR9Jx2ZeWrE
"""

#Question 1 (Reading an Image)
from google.colab import files
uploaded=files.upload()

filename=list(uploaded.keys())[0]

from PIL import Image
from sklearn.cluster import MiniBatchKMeans     # MiniBatchKMeans is faster is computation on small batches as compared to the KMeans
from sklearn.metrics import mean_squared_error
import numpy as np
import matplotlib.pyplot as plt

img=Image.open(filename).resize((960,600))        #resizing-for faster computation
X=np.asarray(img)
plt.imshow(X)
plt.axis('off')
plt.show()

def k_means_quantization(image, k):
    img_array=np.array(image).reshape((-1, 3))    #Reshaping to 2-D arrray
    kmeans=MiniBatchKMeans(n_clusters=k, random_state=0).fit(img_array)
    quantized_img_array=kmeans.cluster_centers_[kmeans.labels_]          #assigning pixels to nearest cluster centers
    quantized_img=quantized_img_array.reshape(image.size[1], image.size[0], 3).astype(np.uint8)
    return Image.fromarray(quantized_img)

def resize_image(image, size=(256, 256)):
  return image.resize(size, Image.ANTIALIAS)

k_values=[1, 2, 4, 8, 16]
mse_values=[]
original_image=Image.open(filename)
for k in k_values:
    quantized_image=k_means_quantization(original_image, k)        #Apply K-means Quantization
    original_array=np.array(original_image)
    quantized_array=np.array(quantized_image)
    mse=mean_squared_error(original_array.flatten(), quantized_array.flatten())     #Computing MSE
    mse_values.append(mse)
    plt.figure(figsize=(6,3))
    plt.title(f'quantized Image with k=[k]')
    plt.imshow(quantized_image)
    plt.axis('off')
    plt.show()

plt.figure(figsize=(8,3))
plt.plot(k_values, mse_values, marker='o', linestyle='-', color='b')
plt.title('Mean Squared Error vs k')
plt.xlabel('Number of clusters(k)')
plt.ylabel('Mean_Squared_Error(MSE)')
plt.grid(True)
plt.show()

print("MSE values for different k:")
for k, mse in zip(k_values, mse_values):
    print(f"k={k}: MSE={mse:.2f}")

print("\nAnalysis:")
print("1. As the number of clusters (k) increases, the Mean Squared Error (MSE) generally decreases.")
print("2. A higher value of k means more colors are used to represent the image, which results in less loss of image detail.")
print("3. However, very high values of k may not always yield significant improvements in image quality and can lead to increased computational cost.")
print("4. For low values of k, the image appears more 'blocky' or 'posterized', with noticeable color banding.")
print("5. The choice of k should balance between image quality and computational efficiency based on the application requirements.")

#Question 2 (Connected Component Analysis)
from google.colab import files
uploaded=files.upload()

filename=list(uploaded.keys())[0]
from PIL import Image
import numpy as np
import matplotlib.pyplot as plt
import scipy.ndimage

image=Image.open(filename).convert('L')
image_np=np.array(image)
threshold=127   # to convert it into a binary image(1,0)
binary_image=(image_np>threshold).astype(np.int32)
labeled_image, num_features=scipy.ndimage.label(binary_image)     # labeled_image-for labelling the connected components, num_features-connected componnets number
plt.figure(figsize=(6,6))
plt.subplot(1,2,1)
plt.imshow(image_np, cmap='gray')
plt.title('Original Image')
plt.axis('Off')
plt.subplot(1,2,2)
plt.imshow(labeled_image, cmap='nipy_spectral')
plt.title(f'Labeled Image-{num_features}Components')
plt.axis('Off')
plt.show()
print(f"Number of connected Components found: {num_features}")

# Connected component labelling helps to counts distinct objects or areas in an image.

# Question 3 (Image Interpolation)
import cv2
import numpy as np
from skimage.metrics import peak_signal_noise_ratio as psnr, mean_squared_error as mse
import matplotlib.pyplot as plt
from PIL import Image

image_512=Image.open("lena_gray_512.tif")    # In Downsampling fewer pixels are used to represent the same image reducing the image resolution, which can lead to a loss of detail.
image_256=image_512.resize((256, 256))    # Resizing of image
image_256.save("reduced_lena_256.tif")

image_1=cv2.imread("lena_gray_256.tif", cv2.IMREAD_GRAYSCALE)
image_2=cv2.imread("reduced_lena_256.tif", cv2.IMREAD_GRAYSCALE)
psnr_value=psnr(image_1, image_2)    # Peak Signal to noise ratio-Higher PSNR indicates better quality (less difference between the two images).
print(f"PSNR value: {psnr_value} dB")    # Psnr measures the quality of the reduced image compared to the original image.

mse_value=mse(image_1, image_2)
print(f"MSE value: {mse_value} dB")

difference_image=cv2.absdiff(image_1, image_2)
plt.imshow(difference_image, cmap='gray')
plt.title("MSE difference Image")
plt.axis('off')
plt.show()

reduced_image = cv2.imread('reduced_lena_256.tif', cv2.IMREAD_GRAYSCALE)

nearest_resized = cv2.resize(reduced_image, (512, 512), interpolation=cv2.INTER_NEAREST)


bilinear_resized = cv2.resize(reduced_image, (512, 512), interpolation=cv2.INTER_LINEAR)


bicubic_resized = cv2.resize(reduced_image, (512, 512), interpolation=cv2.INTER_CUBIC)

# Question 4
import cv2
import matplotlib.pyplot as plt
import numpy as np
def solution():
    noisy_image=cv2.imread('/content/Noisy image.png', cv2.IMREAD_GRAYSCALE)    #cv2.IMREAD_GRAYSCALE is the flag to convert iamge to grayscale.
    filtered_image=cv2.medianBlur(noisy_image, 5)       # Guassian-blurring occurs
    plt.subplot(121), plt.imshow(noisy_image, cmap='gray')
    plt.subplot(122), plt.imshow(filtered_image, cmap='gray')
    plt.show()
solution()

# Question 5
import cv2
import numpy as np
import matplotlib.pyplot as plt

img = cv2.imread("/content/cameraman.tif", cv2.IMREAD_GRAYSCALE)
sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize=3)     # Sobel operator is used to compute the gradient.
sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize=3)

gradient_magnitude = np.sqrt(sobelx**2 + sobely**2)
gradient_magnitude = np.uint8(gradient_magnitude)   # Resulting gradient magnitude is converted to unit8 for diaplay purposes.

_, edge_map = cv2.threshold(gradient_magnitude, 50, 255, cv2.THRESH_BINARY)

laplacian = cv2.Laplacian(img, cv2.CV_64F)   # to compute the second order derivative of the image, for detecting images when the intensity changes sharply.

blurred = cv2.GaussianBlur(img, (3, 3), 0)  # LoG-Combines Gaussian smoothing with the Laplacian to detect edges more robustly.
log = cv2.Laplacian(blurred, cv2.CV_64F)    # The Laplacian is then applied to the blurred image. LoG combines Gaussian smoothing with the Laplacian operator to detect edges more robustly by reducing noise and highlighting edges.

canny_edges = cv2.Canny(img, 100, 200)

plt.figure(figsize=(10, 10))

plt.subplot(3, 2, 1)
plt.title("Original Image")
plt.imshow(img, cmap='gray')

plt.subplot(3, 2, 2)
plt.title("Sobel X")
plt.imshow(sobelx, cmap='gray')

plt.subplot(3, 2, 3)
plt.title("Sobel Y")
plt.imshow(sobely, cmap='gray')

plt.subplot(3, 2, 4)
plt.title("Gradient Magnitude with Thresholding")
plt.imshow(edge_map, cmap='gray')

plt.subplot(3, 2, 5)
plt.title("Laplacian (Second-order derivative)")
plt.imshow(laplacian, cmap='gray')

plt.subplot(3, 2, 6)
plt.title("Canny Edge Detector")
plt.imshow(canny_edges, cmap='gray')

plt.tight_layout()
plt.show()