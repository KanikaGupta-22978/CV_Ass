# -*- coding: utf-8 -*-
"""ass_3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O48CSFCgkiL2fLjKgBnyhQXhDWFuQKqj
"""

import cv2   # tool for image processing
import numpy as np    # tool for data visaulization
import matplotlib.pyplot as plt     #  tool to operate these arrays
import math

# Question 1
# Function to rotate an image by a given angle (custom implementation)
def rotate_image(image, angle):
    # Get the image dimensions
    h, w = image.shape[:2]

    # Calculate the center of the image
    center = (w // 2, h // 2)

    # Create the rotation matrix using the given angle
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)

    # Perform the affine transformation (rotation)
    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h))

    return rotated_image

# Function to visualize the images
def visualize_rotation(image, angles):
    plt.figure(figsize=(12, 8))

    for i, angle in enumerate(angles):
        rotated_custom = rotate_image(image, angle)
        rotated_opencv = rotate_image_opencv(image, angle)

        # Show custom rotated image
        plt.subplot(2, len(angles), i+1)
        plt.imshow(cv2.cvtColor(rotated_custom, cv2.COLOR_BGR2RGB))
        plt.title(f'Custom: {angle}°')
        plt.axis('off')

        # Show OpenCV rotated image
        plt.subplot(2, len(angles), i+1+len(angles))
        plt.imshow(cv2.cvtColor(rotated_opencv, cv2.COLOR_BGR2RGB))
        plt.title(f'OpenCV: {angle}°')
        plt.axis('off')

    plt.show()

# Function to rotate using OpenCV (built-in function)
def rotate_image_opencv(image, angle):
    # Get the dimensions of the image
    h, w = image.shape[:2]

    # Compute the center of the image
    center = (w // 2, h // 2)

    # Get the rotation matrix for OpenCV's function
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)

    # Apply the rotation
    rotated_image = cv2.warpAffine(image, rotation_matrix, (w, h))

    return rotated_image

# Main execution starts here
if __name__ == "__main__":
    # Load the image from file
    image_path = '/content/virtual bg.jpeg'
    image = cv2.imread(image_path)

    # Specify rotation angles
    angles = [30, 60, -45]

    # Visualize the results of both custom and OpenCV rotations
    visualize_rotation(image, angles)

# Question 2
# Function to create the transformation matrix for translation and scaling
def calculate_transformation_matrix(dx, dy, sx, sy):
    # Create a 2x3 transformation matrix
    # [sx,  0,  dx]
    # [ 0, sy,  dy]
    transformation_matrix = np.array([[sx, 0, dx], [0, sy, dy]], dtype=float)

    return transformation_matrix

# Function to apply the transformation matrix to an image
def apply_transformation(image, transformation_matrix):
    h, w = image.shape[:2]  # Get image dimensions
    # Apply the affine transformation
    transformed_image = cv2.warpAffine(image, transformation_matrix, (w, h))

    return transformed_image

# Function to visualize and compare original and transformed images
def visualize_transformations(image, transformations):
    plt.figure(figsize=(12, 8))

    for i, (dx, dy, sx, sy) in enumerate(transformations):
        # Calculate transformation matrix
        transformation_matrix = calculate_transformation_matrix(dx, dy, sx, sy)

        # Apply transformation
        transformed_image = apply_transformation(image, transformation_matrix)

        # Plot the transformed image
        plt.subplot(1, len(transformations), i+1)
        plt.imshow(cv2.cvtColor(transformed_image, cv2.COLOR_BGR2RGB))
        plt.title(f'Translation: ({dx},{dy}), Scaling: ({sx},{sy})')
        plt.axis('off')

    plt.show()

# Main execution starts here
if __name__ == "__main__":
    # Load the image
    image_path = '/content/virtual bg.jpeg'
    image = cv2.imread(image_path)

    # Define transformations with translation (dx, dy) and scaling factors (sx, sy)
    transformations = [
        (50, 30, 1.2, 1.2),   # Translation (50, 30) and scaling (1.2, 1.2)
        (-30, -20, 0.8, 0.8), # Translation (-30, -20) and scaling (0.8, 0.8)
        (10, 50, 1.5, 1.0)    # Translation (10, 50) and scaling (1.5, 1.0)
    ]

    # Visualize transformations
    visualize_transformations(image, transformations)

# Question 3
# Function to create a rotation matrix
def calculate_rotation_matrix(image, angle):
    h, w = image.shape[:2]  # Get image dimensions
    center = (w // 2, h // 2)  # Calculate the center of the image

    # Create rotation matrix
    rotation_matrix = cv2.getRotationMatrix2D(center, angle, 1.0)

    return rotation_matrix

# Function to create a translation matrix
def calculate_translation_matrix(dx, dy):
    # Create a 2x3 translation matrix
    translation_matrix = np.array([[1, 0, dx], [0, 1, dy]], dtype=float)

    return translation_matrix

# Function to combine rotation and translation
def combine_transformations(image, angle, dx, dy):
    # Get the rotation matrix
    rotation_matrix = calculate_rotation_matrix(image, angle)

    # Get the translation matrix
    translation_matrix = calculate_translation_matrix(dx, dy)

    # Apply rotation first
    rotated_image = cv2.warpAffine(image, rotation_matrix, (image.shape[1], image.shape[0]))

    # Apply translation to the rotated image
    transformed_image = cv2.warpAffine(rotated_image, translation_matrix, (image.shape[1], image.shape[0]))

    return transformed_image

# Function to visualize and compare the results
def visualize_combined_transformations(image, transformations):
    plt.figure(figsize=(12, 8))

    for i, (angle, dx, dy) in enumerate(transformations):
        # Apply combined transformation
        transformed_image = combine_transformations(image, angle, dx, dy)

        # Plot the transformed image
        plt.subplot(1, len(transformations), i+1)
        plt.imshow(cv2.cvtColor(transformed_image, cv2.COLOR_BGR2RGB))
        plt.title(f'Rotation: {angle}°, Translation: ({dx},{dy})')
        plt.axis('off')

    plt.show()

# Main execution starts here
if __name__ == "__main__":
    # Load the image
    image_path = '/content/virtual bg.jpeg'
    image = cv2.imread(image_path)

    # Define combined transformations with rotation and translation
    transformations = [
        (30, 50, 30),   # Rotate 30°, then translate (50, 30)
        (60, -30, -20), # Rotate 60°, then translate (-30, -20)
        (-45, 10, 50)   # Rotate -45°, then translate (10, 50)
    ]

    # Visualize the combined transformations
    visualize_combined_transformations(image, transformations)